<h1>Solutions</h1>
<p>There are a few solutions of this situation:</p>
<ol class="task-list">
<li>Resource hierarchy solution</li>
<li>Arbitrator solution</li>
<li>Chandy/Misra solution</li>
</ol>
<h2><a class="anchor" href="https://github.com/epam-mooc/akka-dining-philosophers#arbitrator-solution" name="user-content-arbitrator-solution"></a>Arbitrator solution</h2>
<p>Here you can see implementation of second method: <strong>arbitrator solution</strong> via <strong>actors</strong>. This approach is to guarantee that a philosopher can only pick up both chopsticks or none by introducing an arbitrator, e.g., a waiter. In order to pick up the chopsticks, a philosopher must ask permission of the waiter. The waiter gives permission to only one philosopher at a time until he has picked up both his forks. Putting down a fork is always allowed. The waiter can be implemented as a <strong><em>mutex</em></strong>. In addition to introducing a new central entity (the waiter), this approach can result in reduced parallelism: if a philosopher is eating and one of his neighbors is requesting the forks, all other philosophers must wait until this request has been fulfilled even if forks for them are still available.</p>
<p>You can download source code <strong><a href="https://github.com/epam-mooc/dining-philosophers-akka" target="_blank">here</a></strong>.</p>